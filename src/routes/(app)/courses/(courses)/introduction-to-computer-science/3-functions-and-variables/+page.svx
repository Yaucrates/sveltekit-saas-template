# Functions and Variables

In the previous lesson, we wrote a simple program that would print "Hello, World!" to
the screen. Now, we're going to expand on that program to create one that's more interactive
and dynamic.

---

## Functions and Arguments

Although `hello.py` was simple, it contained two important concepts: *functions* and *arguments*.

```python
print("Hello, World!")
```

In it, `print` is a *function*. Functions are commands that a tell the computer what to do. The
`print` function specifically knows how to take text and output it to the terminal. This text that
it takes as input is known as an argument.

*Arguments* are the pieces of information you give to a function as input so it can do its job.
In `hello.py`, we pass the phrase `"Hello, World!"` as our argument, so that it gets printed to the
screen.

---

## Variables and User Input

As awesome as `hello.py` is, it always prints the same message. To make our programs more dynamic,
we need to introduce the `input` function. The `input` function displays a prompt to the user and
waits for them to type something on their keyboard. Once they've pressed Enter, whatever they typed
is returned from the function for us to use. Let's update `hello.py` to use `input`:

```python
input("What's your name? ")
print("Hello, World!")
```

Although this program does ask for a name, it doesn't actually *remember* what the user typed. This
is because we're not storing the value that `input` is returning to us. To do this, we need to use
*variables*. Variables are names that refer to values we've stored, and we can create one by
assigning a value to it using the assignment operator (`=`). Let's update our program to store the
input inside of a variable called `name`:

> **Important:** You may be used to seeing `=` used in math to assert equality, but in programming,
it means something different. It tells us to take the value on the right, and store it in the variable
on the left.

```python
name = input("What's your name? ")
print("Hello, World!")
```

Now, we want to actually use the name that the user typed. We can do this by passing the variable `name`
as an argument to the `print` function:

```python
name = input("What's your name? ")
print("Hello, ")
print(name)
print("!")
```

> Whitespace is important in Python programs. Make sure to include the spaces where necessary, such as after
the comma in `"Hello, "`.

### Bugs

When you run this program, you'll notice that it prints the greeting and the name on two separate lines.
Mistakes in coding are known as *bugs*, and they are a natural and unavoidable part of the programming
process. This bug is caused by the fact that print starts a new line after every call. To fix this, we can
use the `end` parameter `print` function to specify what should be printed.

```python
name = input("What's your name? ")
print("Hello, ", end="")
print(name, end="")
print("!")
```

Many functions, such as print, have additional parameters like `end` that allow you to customize their
behavior. For `print`, the default value of `end` is `"\n"`, which represents what's known as the newline
character. We will get into special characters a bit more in the next chapter.

Finally, the program prints the greeting and the name on the same line. Although this code works, we'll
come back to this program in the next chapter and improve on it.

---

## Defining Custom Functions

Although Python provides many built-in functions (like `print` and `input`), programmers often need to create
their own. This is done using the `def` keyword. Defining functions allows you to organize code, make it
reusable, and abstract away complexity.

```python
def hello(to="world"):
    print("hello,", to)

name = input("What's your name? ")
hello(name)
hello()
```

`def hello(to="world"):` defines a function named `hello` that accepts one *parameter* named `to`. Parameters
are what we call the variables listed in a function's definition. They act as placeholders for the arguments
that will be passed in when the function is called.

The `to="world"` part makes `to` a *default parameter*. This means if the caller does not provide an argument,
`to` will automatically default to `"world"`. That's why `hello()` prints `"hello, world"` while `hello(name)`
prints the user's name instead.

You'll also notice that the `print` line is *indented* under `def`. Python relies on indentation to define
*scope*. Everything indented under `def` is part of that function's body.

### Return Values
Sometimes a function performs a calculation but doesn't print it immediately. Instead, it sends the result
back to the part of the program that called it. This is done using `return`.

```python
def square(n):
    return n * n

x = int(input("What's x? "))
print("x squared is", square(x))
```

In this example, `square` takes the number `n`, multiplies it by itself, and *returns* that value back to
the caller. The returned value is then passed directly into the `print` function.

---

## The `main` Function

As your programs grow, you'll notice that having loose code scattered at the top level of a file can get
messy. A common convention in Python is to place your program's primary logic inside a function called
`main`, and then call it at the bottom of the file.

Let's refactor our previous examples to use this pattern:

```python
def hello(to="world"):
    print("hello,", to)

def main():
    name = input("What's your name? ")
    hello(name)
    hello()

main()
```

```python
def square(n):
    return n * n

def main():
    x = int(input("What's x? "))
    print("x squared is", square(x))

main()
```

By wrapping your logic in `main`, you keep your program organized and make it clear where execution
begins. This becomes especially important as your files grow larger and contain multiple function
definitions.
