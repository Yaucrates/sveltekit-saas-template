# Chapter 2: Functions, Variables, and Operators

In the previous lesson, we wrote a simple program that would print "Hello, World!" to
the screen. Now, we're going to expand on that program to create one that's more interactive
and dynamic.

---

## Functions and Arguments

Although `hello.py` was simple, it contained two important concepts: *functions* and *arguments*.

```python
print("Hello, World!")
```

In it, `print` is a *function*. Functions are commands that a tell the computer what to do. The
`print` function specifically knows how to take text and output it to the terminal. This text that
it takes as input is known as an argument.

*Arguments* are the pieces of information you give to a function as input so it can do its job.
In `hello.py`, we pass the phrase `"Hello, World!"` as our argument, so that it gets printed to the
screen.

---

## Variables and User Input

As awesome as `hello.py` is, it always prints the same message. To make our programs more dynamic,
we need to introduce the `input` function. The `input` function waits for the user to type something
on their keyboard and press Enter. Once they do, whatever they typed is returned from the function
for us to use. Let's update `hello.py` to use `input`:

```python
input()
print("Hello, World!")
```

If you run this, you'll notice the program pauses and waits for you to type something before
continuing. It works, but there's no indication of *what* the user should type. We can fix this by
passing an argument to `input`, which will be displayed as a prompt:

```python
input("What's your name? ")
print("Hello, World!")
```

Now the user sees a message asking for their name. However, the program still doesn't actually
*remember* what the user typed. This is because we're not storing the value that `input` is
returning to us. To do this, we need to use
*variables*. Variables are names that refer to values we've stored, and we can create one by
assigning a value to it using the assignment operator (`=`). Let's update our program to store the
input inside of a variable called `name`:

> **Important:** You may be used to seeing `=` used in math to assert equality, but in programming,
it means something different. It tells us to take the value on the right, and store it in the variable
on the left.

```python
name = input("What's your name? ")
print("Hello, World!")
```

Now, we want to actually use the name that the user typed. We can do this by passing the variable `name`
as an argument to the `print` function:

```python
name = input("What's your name? ")
print("Hello, ")
print(name)
print("!")
```

> Whitespace is important in Python programs. Make sure to include the spaces where necessary, such as after
the comma in `"Hello, "`.

### Strings

Let's take a moment to name something we've been using all along. Values like
`"Hello, World!"` and `"What's your name? "` are called **strings**. A string is a sequence of
characters enclosed in quotation marks, and it's how we represent text in Python.

> Note: You can use both `'single quotes'` and `"double quotes"` interchangably in Python.

When you call `input("What's your name? ")`, the value the user types is also returned as a string.
In fact, every piece of text you've seen so far in our programs has been a string.

Strings are one of several **types** of data in Python. Each type represents a different kind of value,
such as text, numbers, or true/false conditions. We'll explore types in much more detail in the next
lesson, but for now, just know that strings are the type used for text.

### Bugs

When you run this program, you'll notice that it prints the greeting and the name on separate lines.

```txt
Hello, 
John Doe
!
```

Mistakes in coding are known as *bugs*, and they are a natural and unavoidable part of the programming
process.

This bug is caused by the fact that `print` automatically adds a special character called `\n` (a
*newline*) at the end of every call, which moves the output to the next line. To fix this, we can
use the `end` parameter of the `print` function to override the default behavior:

```python
name = input("What's your name? ")
print("Hello, ", end="")
print(name, end="")
print("!")
```

By setting `end=""`, we're replacing the default `\n` with nothing, so the next `print` continues on
the same line. Many functions, like `print`, have additional parameters that allow you to customize
their behavior.

### Documentation

But how would you have known that `end` existed in the first place? This is where **documentation**
comes in. Documentation is the official reference material that describes how a language, library, or
function works. For Python, the most important resource is the [official documentation](https://docs.python.org/3/)
although you can use any resource you want online.

Documentation takes some experience to understand. Taking a look at the documentation for the `print`
function, we see how print is defined followed by an explaination. The definition is as follows:

```python
print(*objects, sep=' ', end='\n', file=None, flush=False)
```

This tells us that `print` accepts several parameters. Let's break them down:

*   `*objects`: The `*` means `print` can accept any number of arguments. That's why
    `print("hello", "world")` works just as well as `print("hello")`â€”you can pass one value
    or many.
*   `sep=' '`: Short for *separator*. When you pass multiple arguments, `sep` controls what
    goes between them. The default is a space, which is why `print("hello", "world")` outputs
    `hello world`. You could change it:

```python
print("hello", "world", sep="-")
```

```
hello-world
```

*   `end='\n'`: This is the one we already used! It controls what gets printed at the very
    end. The default is `\n` (a newline), which is why each `print` normally starts a new
    line. Earlier, we set `end=""` to prevent that.
*   `file` and `flush`: These control *where* the output goes and *when* it's sent. You won't
    need these for now.

Don't worry if documentation feels overwhelming at first. The key skill is learning to scan
for what you need rather than reading everything top to bottom. With practice, you'll find
that documentation is one of the most reliable tools you have as a programmer.

### AI

You've probably heard of and used AI tools like ChatGPT, Claude, and GitHub Copilot. These tools can write
code, explain concepts, and answer programming questions. They are real, they are powerful, and
professional developers use them every day.

However, if you're just starting to learn programming, **relying on AI too early can seriously
hurt your growth.** Think of it like using a calculator before you understand arithmetic. The
calculator gives you the right answer, but you never build the intuition for *why* it's right. When
something goes wrong, you won't know how to fix it. When the problem changes slightly, you won't
know how to adapt.

Now--going back to our earlier program--it finally prints the greeting and the name on the same
line, but it's awful to look at and read. There has to be a better way! What if we could combine
the text?

### Operators

An **operator** is a symbol that performs an operation on one or more values. You've already seen the
assignment operator (`=`), which stores a value in a variable. Another common operator is the `+`
operator, which, when used on strings, **concatenates** (joins) them together:

```python
print("Hello, " + "World" + "!")
```

```
Hello, World!
```

Using `+`, we can collapse our three `print` calls into a single, clean line:

```python
name = input("What's your name? ")
print("Hello, " + name + "!")
```

This is much easier to read and does exactly the same thing.

### F-Strings

While `+` works well for simple cases, there's an even cleaner way to combine text and variables:
**format strings**, or **f-strings**. By placing an `f` before the opening quotation mark, you can
insert variables directly into the string using curly braces `{}`:

```python
name = input("What's your name? ")
print(f"Hello, {name}!")
```

F-strings are the preferred way to build strings in modern Python, and you'll see them used
throughout the rest of this course.

### String Methods

Python strings come with built-in functions, called **methods**, to manipulate text. Because users are unpredictable (they might accidentally type spaces or forget to capitalize), we can use methods to clean up their input.

*   `.strip()`: Removes whitespace from the beginning and end of a string.
*   `.title()`: Capitalizes the first letter of each word.

These methods can be "chained" together to clean up user input in one line:

```python
# Ask user for name, remove whitespace, and title case it
name = input("What's your name? ").strip().title()

print(f"Hello, {name}!")
```

### Errors

As you write code, it's important to realize you will make mistakes. Sometimes
Python will catch a mistake *before* your program even runs. These are called
**syntax errors**, and they occur when your code breaks the rules of the Python
language.

For example, try running this:

```python
print("hello"
```

Python will refuse to run it and display an error message:

```
  File "hello.py", line 1
    print("hello"
         ^
SyntaxError: '(' was never closed
```

Python is telling us exactly what went wrong and where. The `^` arrow points to the spot where it noticed
the problem, and the message explains that the opening `(` was never matched with a closing `)`. To fix
it, we simply add the missing parenthesis:

```python
print("hello")
```

This applies to more than just parentheses. Python expects matching pairs for quotes, brackets, and
braces. If you ever see a `SyntaxError`, it means you've written something Python doesn't allow.

> As you write more code, you'll quickly get used to reading error messages. They might look intimidating
at first, but they're one of the most helpful tools you have for finding and fixing mistakes.

### Special Characters

We already saw the `\n` newline character when fixing our bug. The `\n` is an example of an **escape
sequence**, a combination of a backslash (`\`) followed by a character that represents something
special.

Escape sequences are necessary because some characters can't be typed directly into a string. For
instance, since Python uses quotes to mark the boundaries of a string, what happens if your text itself
contains a quote?

```python
print("She said "hello" to me")
```

Python sees the quote before `hello` and thinks the string has ended, causing a `SyntaxError`. To include
a quote character inside a string, you need to *escape* it by placing a backslash before it:

```python
print("She said \"hello\" to me")
```

The backslash tells Python: "don't treat the next character as special--treat it literally." Here are the
most common escape sequences:

| Escape Sequence | What It Produces |
|:---:|:---|
| `\"` | A double quote |
| `\'` | A single quote |
| `\\` | A literal backslash |
| `\n` | A newline (moves to the next line) |
| `\t` | A tab (horizontal space) |

For example:

```python
print("Line one\nLine two")
print("Name:\tAlice")
```

```
Line one
Line two
Name:	Alice
```

---

## Defining Custom Functions

Although Python provides many built-in functions (like `print` and `input`), programmers often need to create
their own. This is done using the `def` keyword. Defining functions allows you to organize code, make it
reusable, and abstract away complexity.

```python
def hello(to="world"):
    print("hello,", to)

name = input("What's your name? ")
hello(name)
hello()
```

`def hello(to="world"):` defines a function named `hello` that accepts one *parameter* named `to`. Parameters
are what we call the variables listed in a function's definition. They act as placeholders for the arguments
that will be passed in when the function is called.

The `to="world"` part makes `to` a *default parameter*. This means if the caller does not provide an argument,
`to` will automatically default to `"world"`. That's why `hello()` prints `"hello, world"` while `hello(name)`
prints the user's name instead.

You'll also notice that the `print` line is *indented* under `def`. Python relies on indentation to define
*scope*. Everything indented under `def` is part of that function's body.

### Return Values
Sometimes a function performs a calculation but doesn't print it immediately. Instead, it sends the result
back to the part of the program that called it. This is done using `return`.

```python
def square(n):
    return n * n

x = int(input("What's x? "))
print("x squared is", square(x))
```

In this example, `square` takes the number `n`, multiplies it by itself, and *returns* that value back to
the caller. The returned value is then passed directly into the `print` function.

---

## The `main` Function

As your programs grow, you'll notice that having loose code scattered at the top level of a file can get
messy. A common convention in Python is to place your program's primary logic inside a function called
`main`, and then call it at the bottom of the file.

Let's refactor our previous examples to use this pattern:

```python
def hello(to="world"):
    print("hello,", to)

def main():
    name = input("What's your name? ")
    hello(name)
    hello()

main()
```

```python
def square(n):
    return n * n

def main():
    x = int(input("What's x? "))
    print("x squared is", square(x))

main()
```

By wrapping your logic in `main`, you keep your program organized and make it clear where execution
begins. This becomes especially important as your files grow larger and contain multiple function
definitions.
